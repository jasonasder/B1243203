<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>圓周運動（Rotation of Rigid Bodies）</title>
<style>
  body { 
    font-family: "Microsoft JhengHei", sans-serif; 
    margin:0; padding:0; 
    background: url('img/bb.webp') no-repeat center center fixed; 
    background-size: cover;
    color:#333; 
    line-height:1.8; 
  }

  nav {
    background: rgba(44, 62, 80);
    padding: 15px 20px;
    display: flex;
    justify-content: center;
    position: sticky;
    top: 0;
    z-index: 1000;
  }
  nav .menu a {
    color: #ecf0f1;
    text-decoration: none;
    margin: 0 15px;
    font-size: 16px;
    font-weight: bold;
    transition: 0.3s;
  }
  nav .menu a:hover { color: #f1c40f; }

  header { 
    background: rgba(52, 73, 94, 0.85); 
    color:white; 
    text-align:center; 
    padding:10px 10px; 
  }
  h1 { margin:0; font-size:50px; }

  section{ 
    max-width:900px; 
    margin:25px auto; 
    background: rgba(255, 255, 255, 0.92); 
    border-radius:12px; 
    box-shadow:0 8px 32px rgba(0,0,0,0.2); 
    padding:30px 40px; 
  }

  h2{ 
    color:#1a5276; 
    border-left:6px solid #1a5276; 
    padding-left:15px; 
    margin-top:18px; 
    font-size: 35px;
  }
  p{ font-size: 20px; text-align:justify; }

  .formula-box {
    background: rgba(26, 82, 118, 0.05);
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #1a5276;
    margin: 15px 0;
    font-family: "Times New Roman", Times, serif;
  }

  .control-panel {
    background: #fdfefe;
    border: 1px solid #d5dbdb;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
  }

  .control { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 15px; 
  }
  .control-row {
    display: flex;
    justify-content: center;
    gap: 20px;
    flex-wrap: wrap;
    align-items: center;
  }

  label { font-size: 22px; font-weight: bold; }
  input, select { font-size:16px; padding:6px; width: 80px; border-radius:4px; border:1px solid #ccc; }
  select { width: 120px; }
  
  button { 
    background:#1a5276; 
    color:#fff; 
    border:none; 
    border-radius:5px; 
    cursor:pointer; 
    padding: 8px 20px;
    font-size: 18px;
    transition: 0.3s;
  }
  button:hover { background:#2471a3; transform: scale(1.05); }

  #info { 
    display:flex; 
    justify-content:center; 
    gap:20px; 
    margin-top:15px; 
    border-top: 1px solid #eee;
    padding-top: 15px;
    flex-wrap: wrap;
  }
  #info p { font-size: 22px; font-weight: bold; margin: 5px; }
  #info strong { color: #d35400; }

  canvas{ 
    display:block; 
    margin:20px auto; 
    border:2px solid #333; 
    background:#fff; 
    border-radius: 5px;
  }
</style>
</head>
<body>

<nav>
  <div class="menu">
    <a href="index.html">首頁 (Home)</a>
    <a href="Equilibrium & Elasticity.html">平衡與彈性</a>
    <a href="Mechanical Waves.html">機械波</a>
    <a href="Projectile Motion.html">拋體運動</a>
    <a href="Rotation of Rigid Bodies.html" style="color:#f1c40f">圓周旋轉</a>
    <a href="Sound & Hearing.html">聲音聽覺</a>
  </div>
</nav>

<header><h1>圓周運動（Rotation of Rigid Bodies）</h1></header>

<section>
  <h2>定律內容</h2>
  <p>
    圓周運動指物體以固定半徑圍繞一中心做圓周路徑運動的情形。若為勻速圓周運動，角速度（或角頻率）維持恆定，則物體具有向心加速度，其方向指向圓心。
  </p>

  

  <h2>公式表示</h2>
  <div class="formula-box">
    角速度：ω（rad/s）<br>
    線速度：v = ω · r<br>
    向心加速度：a_c = v² / r = ω² · r<br>
    向心力：F_c = m · a_c = m · ω² · r<br>
    週期：T = 2π / ω
  </div>

  <h2>圖像理解</h2>
  <p>
    圓周運動的向心加速度方向始終指向圓心，速度方向切線於軌道。畫布上會顯示質點、軌道圓圈、速度或向心力向量，幫助理解速度與加速度方向的差異。
  </p>

  <h2>適用範圍</h2>
  <p>
    本模型適用於剛體或質點作圓周運動，忽略空氣阻力或其他摩擦力的理想情形。
  </p>

  <h2>常見應用</h2>
  <p>
    汽車轉彎的向心力、旋轉機械（風扇、轉子）、行星近似運動、離心機設計等。
  </p>
</section>

<section>
  <h2>實驗模擬：圓周運動</h2>

  <div class="control-panel">
    <div class="control">
      <div class="control-row">
        <label>半徑 r (m)：<input id="r" type="number" value="80" min="1" step="1"></label>
        <label>角速度 ω (rad/s)：<input id="omega" type="number" value="2" step="0.1"></label>
      </div>
      <div class="control-row">
        <label>質量 m (kg)：<input id="mass" type="number" value="1" step="0.1"></label>
        <label>顯示向量：
          <select id="showVec">
            <option value="none">不顯示</option>
            <option value="v" selected>速度 v</option>
            <option value="a">向心加速度 a_c</option>
            <option value="F">向心力 F_c</option>
          </select>
        </label>
        <button onclick="startRotation()">開始</button>
        <button onclick="stopRotation()" style="background:#d35400;">停止</button>
        <button onclick="resetRotation()" style="background:#7f8c8d;">重設</button>
      </div>
    </div>

    <div id="info">
      <p>ω: <strong id="omegaVal">2.00</strong> rad/s</p>
      <p>v: <strong id="vVal">0.00</strong> m/s</p>
      <p>a_c: <strong id="aVal">0.00</strong> m/s²</p>
      <p>F_c: <strong id="FVal">0.00</strong> N</p>
      <p>T: <strong id="TVal">0.00</strong> s</p>
    </div>
  </div>

  <canvas id="c" width="900" height="500"></canvas>
</section>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let r_m = parseFloat(document.getElementById('r').value); 
let omega = parseFloat(document.getElementById('omega').value); 
let mass = parseFloat(document.getElementById('mass').value); 
const scale = 2; 
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

let angle = 0;
let rotating = false;
let lastTimestamp = null;

const omegaVal = document.getElementById('omegaVal');
const vVal = document.getElementById('vVal');
const aVal = document.getElementById('aVal');
const FVal = document.getElementById('FVal');
const TVal = document.getElementById('TVal');
const showVec = document.getElementById('showVec');

function updateInfo() {
  omegaVal.innerText = omega.toFixed(2);
  const v = omega * r_m;
  const a_c = omega * omega * r_m; 
  const F_c = mass * a_c; 
  const T = omega === 0 ? Infinity : (2 * Math.PI / omega);

  vVal.innerText = v.toFixed(2);
  aVal.innerText = a_c.toFixed(2);
  FVal.innerText = F_c.toFixed(2);
  TVal.innerText = (isFinite(T) ? T.toFixed(2) : '∞');
}

function drawScene() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const r_px = r_m * scale;
  
  // 畫圓形軌道
  ctx.beginPath();
  ctx.strokeStyle = '#b8c0c6';
  ctx.setLineDash([5, 5]); // 虛線軌道
  ctx.lineWidth = 1;
  ctx.arc(centerX, centerY, r_px, 0, Math.PI * 2);
  ctx.stroke();
  ctx.setLineDash([]); // 恢復實線

  const px = centerX + r_px * Math.cos(angle);
  const py = centerY + r_px * Math.sin(angle);

  // 畫質點
  ctx.beginPath();
  ctx.fillStyle = '#1c7ed6';
  ctx.arc(px, py, 12, 0, Math.PI * 2);
  ctx.fill();

  const sel = showVec.value;
  if (sel === 'v') {
    const v = omega * r_m;
    const len = Math.min(120, v * 0.5);
    const tx = -Math.sin(angle); 
    const ty = Math.cos(angle);  
    drawArrow(px, py, px + tx * len, py + ty * len, '#27ae60');
  } else if (sel === 'a') {
    const a_c = omega * omega * r_m;
    const len = Math.min(100, a_c * 0.1);
    const ux = (centerX - px) / r_px;
    const uy = (centerY - py) / r_px;
    drawArrow(px, py, px + ux * len, py + uy * len, '#e67e22');
  } else if (sel === 'F') {
    const a_c = omega * omega * r_m;
    const F = mass * a_c;
    const len = Math.min(100, F * 0.1);
    const ux = (centerX - px) / r_px;
    const uy = (centerY - py) / r_px;
    drawArrow(px, py, px + ux * len, py + uy * len, '#8e44ad');
  }

  // 中心點
  ctx.beginPath();
  ctx.fillStyle = '#333';
  ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
  ctx.fill();
}

function drawArrow(x1, y1, x2, y2, color) {
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  const a = Math.atan2(y2 - y1, x2 - x1);
  const headLen = 10;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen * Math.cos(a - Math.PI/6), y2 - headLen * Math.sin(a - Math.PI/6));
  ctx.lineTo(x2 - headLen * Math.cos(a + Math.PI/headLen), y2 - headLen * Math.sin(a + Math.PI/6));
  ctx.closePath();
  ctx.fill();
}

function animate(timestamp) {
  if (!rotating) return;
  if (!lastTimestamp) lastTimestamp = timestamp;
  const dt = (timestamp - lastTimestamp) / 1000; 
  lastTimestamp = timestamp;
  angle += omega * dt;
  updateInfo();
  drawScene();
  requestAnimationFrame(animate);
}

function startRotation() {
  r_m = parseFloat(document.getElementById('r').value);
  omega = parseFloat(document.getElementById('omega').value);
  mass = parseFloat(document.getElementById('mass').value);
  rotating = true;
  lastTimestamp = null;
  updateInfo();
  requestAnimationFrame(animate);
}

function stopRotation() {
  rotating = false;
  lastTimestamp = null;
}

function resetRotation() {
  stopRotation();
  angle = 0;
  document.getElementById('r').value = 80;
  document.getElementById('omega').value = 2;
  document.getElementById('mass').value = 1;
  r_m = 80; omega = 2; mass = 1;
  updateInfo();
  drawScene();
}

updateInfo();
drawScene();
</script>
</body>
</html>